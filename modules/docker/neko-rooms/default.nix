{
  config,
  lib,
  pkgs,
  ...
}:
with lib;
let
  cfg = config.services.nekorooms;
in
{
  options = {
    services.nekorooms = {
      enable = mkEnableOption "neko-rooms";
      port = mkOption {
        type = types.int;
        description = "The port for the instance to bind to.";
        default = 8080;
      };
      nat1to1 = mkOption {
        type = types.str;
        description = "IP of the server that will be sent to client, if not specified, public IP is automatically resolved.";
        default = "127.0.0.1";
      };
      instanceURL = mkOption {
        type = types.str;
        description = "The external URL at which your instance will be accessible.";
        default = "http://127.0.0.1:8080/";
      };
      pathPrefix = mkOption {
        type = types.str;
        description = "";
        default = "/room/";
      };
      roomPortRange = {
        min = mkOption {
          type = types.int;
          description = "";
          default = 59000;
        };
        max = mkOption {
          type = types.int;
          description = "";
          default = 59049;
        };
      };
    };
  };

  # == compose2nix generated code below ==
  config = mkIf cfg.enable {
    # Runtime
    virtualisation.docker = {
      enable = true;
      autoPrune.enable = true;
      rootless = {
        enable = true;
        setSocketVariable = true;
      };
    };
    virtualisation.oci-containers.backend = "docker";

    # Containers
    virtualisation.oci-containers.containers."nr-neko-rooms" = {
      image = "m1k1o/neko-rooms:latest";
      environment = {
        "NEKO_ROOMS_EPR" =
          "${(builtins.toString cfg.roomPortRange.min)}-${(builtins.toString cfg.roomPortRange.max)}";
        "NEKO_ROOMS_INSTANCE_NETWORK" = "neko-rooms-net";
        "NEKO_ROOMS_INSTANCE_URL" = "${cfg.instanceURL}";
        "NEKO_ROOMS_MUX" = "true";
        "NEKO_ROOMS_NAT1TO1" = "${cfg.nat1to1}";
        "NEKO_ROOMS_PATH_PREFIX" = "${cfg.pathPrefix}";
        "NEKO_ROOMS_STORAGE_EXTERNAL" = "/opt/neko-rooms/data";
        "NEKO_ROOMS_STORAGE_INTERNAL" = "/data";
        "NEKO_ROOMS_TRAEFIK_ENABLED" = "false";
        "TZ" = "Etc/UTC";
      };
      volumes = [
        "/opt/neko-rooms/data:/data:rw"
        "/var/run/docker.sock:/var/run/docker.sock:rw"
      ];
      ports = [
        "${(builtins.toString cfg.port)}:8080/tcp"
      ];
      log-driver = "journald";
      extraOptions = [
        "--network-alias=neko-rooms"
        "--network=neko-rooms-net"
      ];
    };
    systemd.services."docker-nr-neko-rooms" = {
      serviceConfig = {
        Restart = lib.mkOverride 90 "always";
        RestartMaxDelaySec = lib.mkOverride 90 "1m";
        RestartSec = lib.mkOverride 90 "100ms";
        RestartSteps = lib.mkOverride 90 9;
      };
      after = [
        "docker-network-neko-rooms-net.service"
      ];
      requires = [
        "docker-network-neko-rooms-net.service"
      ];
      partOf = [
        "docker-compose-nr-root.target"
      ];
      wantedBy = [
        "docker-compose-nr-root.target"
      ];
    };

    # Networks
    systemd.services."docker-network-neko-rooms-net" = {
      path = [ pkgs.docker ];
      serviceConfig = {
        Type = "oneshot";
        RemainAfterExit = true;
        ExecStop = "docker network rm -f neko-rooms-net";
      };
      script = ''
        docker network inspect neko-rooms-net || docker network create neko-rooms-net
      '';
      partOf = [ "docker-compose-nr-root.target" ];
      wantedBy = [ "docker-compose-nr-root.target" ];
    };

    # Root service
    # When started, this will automatically create all resources and start
    # the containers. When stopped, this will teardown all resources.
    systemd.targets."docker-compose-nr-root" = {
      unitConfig = {
        Description = "Root target generated by compose2nix.";
      };
      wantedBy = [ "multi-user.target" ];
    };
  };
}
